<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.6.30">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>Badge 8 Named Entity Recognition</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { display: inline-block; text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
</style>


<script src="nlp_badge_081_Named_Entity_Recognition_1.3_files/libs/clipboard/clipboard.min.js"></script>
<script src="nlp_badge_081_Named_Entity_Recognition_1.3_files/libs/quarto-html/quarto.js"></script>
<script src="nlp_badge_081_Named_Entity_Recognition_1.3_files/libs/quarto-html/popper.min.js"></script>
<script src="nlp_badge_081_Named_Entity_Recognition_1.3_files/libs/quarto-html/tippy.umd.min.js"></script>
<script src="nlp_badge_081_Named_Entity_Recognition_1.3_files/libs/quarto-html/anchor.min.js"></script>
<link href="nlp_badge_081_Named_Entity_Recognition_1.3_files/libs/quarto-html/tippy.css" rel="stylesheet">
<link href="nlp_badge_081_Named_Entity_Recognition_1.3_files/libs/quarto-html/quarto-syntax-highlighting-3a01e2046221230fdceeea94b1ec5d67.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="nlp_badge_081_Named_Entity_Recognition_1.3_files/libs/bootstrap/bootstrap.min.js"></script>
<link href="nlp_badge_081_Named_Entity_Recognition_1.3_files/libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="nlp_badge_081_Named_Entity_Recognition_1.3_files/libs/bootstrap/bootstrap-34745567add538a638dde46bc8a747e1.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">


</head>

<body class="fullcontent">

<div id="quarto-content" class="page-columns page-rows-contents page-layout-article">

<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">Badge 8 Named Entity Recognition</h1>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  


</header>


<section id="named-entity-recognition" class="level1">
<h1>Named Entity Recognition</h1>
<p>In this notebook we will try a few tools for recognising entities (places, people, etc). You will notice that sometimes the tools work really well, and sometimes they do not. We will look at ways to cleanup data, but also we might later look at ways to pick the most appropriate model for the task at hand.</p>
<section id="pipes-all-the-pipes" class="level2">
<h2 class="anchored" data-anchor-id="pipes-all-the-pipes">Pipes! All the Pipes!</h2>
<p>You already noticed that while we learn about NLP we also experience some new advanced elements of R language. You already know <code>%&gt;%</code> pipe, but recently R community is using more and more a simpler (ubt just as powerful) syntax for a pipe <code>|&gt;</code>. It is made of two symbols: a vertical line <code>|</code> (which depending on your keyboard could be on the very right-hand-side, or very left-hand-side) and the larger-than symbol <code>&gt;</code>.</p>
<p>You can use <code>|&gt;</code> pipe in the same way as <code>%&gt;%</code>. But some very advanced uses are different.</p>
<p>Additionally you can import a number of other special pipes. Further down in this notebook we will import from <code>magrittr</code> an ‘self-assignment’ pipe. So that instead of saying <code>students &lt;- students</code></p>
<p>now we have this new pipe, so <code>people &lt;- people %&gt;%  transform(...</code> can become <code>people %&lt;&gt;% transform(...</code> because <code>%&lt;&gt;%</code> pipe means, <strong>apply this pipe to yourself</strong></p>
<div class="cell">
<div class="sourceCode cell-code" id="cb1"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a>people <span class="ot">&lt;-</span> <span class="fu">data.frame</span>(</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>  <span class="at">name =</span> <span class="fu">c</span>(<span class="st">"Alice"</span>, <span class="st">"Vikkie"</span>, <span class="st">"Pim"</span>)</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>people <span class="ot">&lt;-</span> people <span class="sc">%&gt;%</span> <span class="fu">transform</span>( </span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>   <span class="at">name_length=</span> <span class="fu">nchar</span>(name)) </span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>people</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>    name name_length
1  Alice           5
2 Vikkie           6
3    Pim           3</code></pre>
</div>
<div class="sourceCode cell-code" id="cb3"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a>people <span class="sc">%&lt;&gt;%</span> <span class="fu">transform</span>( </span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a>   <span class="at">name_length=</span> <span class="fu">nchar</span>(name)) </span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a>people</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>    name name_length
1  Alice           5
2 Vikkie           6
3    Pim           3</code></pre>
</div>
</div>
<p>You can read about it some other time, but for now, let’s get back to NLP:</p>
</section>
<section id="additional-data-imported-with-packages-eg.-gapminder-for-country-codes" class="level2">
<h2 class="anchored" data-anchor-id="additional-data-imported-with-packages-eg.-gapminder-for-country-codes">Additional data imported with packages (eg. gapminder for country codes)</h2>
<p>We are going to look at a couple different NER packages that we can use Out-Of-the-Box. The first two examples are using lexicons to find and match against tokens in our text.</p>
<p>First we need to load a lexicon to use to find entities in our text. We are going to use a list of countries from the package <em>gapminder.</em> The is a data package with a subset from the Gapminder data. The provides gapminder data in a data frame or “tibble”. There are other aspects, such as pre-made color schemes for the countries and continents, and ISO 3166-1 country codes.</p>
<p>Let’s load the libraries we need. and then take a look with <em>head</em> to see what is in the countries list.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb5"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="co">#Gapminder package will give us a lexicon of countries</span></span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a>country_codes <span class="sc">|&gt;</span> <span class="fu">head</span>(<span class="dv">10</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code># A tibble: 10 × 3
   country     iso_alpha iso_num
   &lt;chr&gt;       &lt;chr&gt;       &lt;int&gt;
 1 Afghanistan AFG             4
 2 Albania     ALB             8
 3 Algeria     DZA            12
 4 Angola      AGO            24
 5 Argentina   ARG            32
 6 Armenia     ARM            51
 7 Aruba       ABW           533
 8 Australia   AUS            36
 9 Austria     AUT            40
10 Azerbaijan  AZE            31</code></pre>
</div>
</div>
<p>We will load our Corona data into a data frame and then create a string from our Corona dataframe <code>text</code> column and then look for any country mentions.</p>
<p>We use <code>str_flatten</code> to create a string from our column text data. <code>str_flatten</code> reduces a character vector to a single string - it is concatenating all the strings in the text column to a single sting.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb7"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="co">#Load the corona csv to a datframe</span></span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a>file_path<span class="ot">=</span><span class="st">'./data/CORONA_TWEETS.csv'</span></span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a>Corona_NLP_DF <span class="ot">&lt;-</span> <span class="fu">read.csv</span>(file_path, <span class="at">stringsAsFactors =</span><span class="cn">FALSE</span>, <span class="at">header=</span><span class="cn">TRUE</span>)</span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a><span class="co">#Creating a str from our Corona data text column</span></span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true" tabindex="-1"></a>corona_text <span class="ot">&lt;-</span> Corona_NLP_DF<span class="sc">$</span>text <span class="sc">|&gt;</span></span>
<span id="cb7-6"><a href="#cb7-6" aria-hidden="true" tabindex="-1"></a>  <span class="fu">str_flatten</span>()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Below <code>country_codes</code> comes from loading the gapminder package. We use mutate to create an extra column called <code>times_mentioned</code> and use the <code>str_count</code> function to look for the country. Then with filter if a country is not mentioned we filter it out.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb8"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a>country_counts_just_words <span class="ot">&lt;-</span> country_codes <span class="sc">|&gt;</span></span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a>  <span class="fu">mutate</span>(<span class="at">times_mentioned =</span> <span class="fu">str_count</span>(corona_text, country)) <span class="sc">|&gt;</span></span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a>  <span class="fu">filter</span>(times_mentioned <span class="sc">&gt;</span> <span class="dv">0</span>)</span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true" tabindex="-1"></a><span class="co">#here we are rearranging country_counts_just_words by desc order of times mentioned</span></span>
<span id="cb8-6"><a href="#cb8-6" aria-hidden="true" tabindex="-1"></a>country_counts_just_words_ordered <span class="ot">&lt;-</span> country_counts_just_words <span class="sc">|&gt;</span></span>
<span id="cb8-7"><a href="#cb8-7" aria-hidden="true" tabindex="-1"></a>  <span class="fu">arrange</span>(<span class="fu">desc</span>(times_mentioned))</span>
<span id="cb8-8"><a href="#cb8-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-9"><a href="#cb8-9" aria-hidden="true" tabindex="-1"></a>country_counts_just_words_ordered</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code># A tibble: 75 × 4
   country   iso_alpha iso_num times_mentioned
   &lt;chr&gt;     &lt;chr&gt;       &lt;int&gt;           &lt;int&gt;
 1 Canada    CAN           124              72
 2 China     CHN           156              50
 3 Italy     ITA           380              36
 4 India     IND           356              27
 5 Kenya     KEN           404              18
 6 Russia    RUS           643              17
 7 Belgium   BEL            56              14
 8 Spain     ESP           724              12
 9 Australia AUS            36              11
10 Qatar     QAT           634               9
# ℹ 65 more rows</code></pre>
</div>
</div>
<p>This time we are going to use the <code>lexicon</code> package to get a list of <code>names</code> to look for in our data.</p>
<p>Activity: Google the <code>R lexicon package</code> to see other lexicon options this package has to offer.</p>
<p><a href="https://github.com/trinker/lexicon">Also useful is the github page</a></p>
<p>Let’s load the required package - you may need to install lexicon first.</p>
<p>The first thing we are doing is creating a data frame of common names. We are taking these from the <code>freq_first name</code> and <em>freq_last_name</em> lexicons and converting them into data frames. Click on the dataframes in the environment to see their content.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb10"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Load frequent first names dataset</span></span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a><span class="fu">data</span>(<span class="st">"freq_first_names"</span>, <span class="at">package =</span> <span class="st">"lexicon"</span>)</span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a><span class="co"># Convert common_names to a dataframe if it is a list</span></span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true" tabindex="-1"></a><span class="co">#if (is.list(freq_first_names)) {</span></span>
<span id="cb10-5"><a href="#cb10-5" aria-hidden="true" tabindex="-1"></a>  <span class="co">#freq_first_names &lt;- as.data.frame(freq_first_names)</span></span>
<span id="cb10-6"><a href="#cb10-6" aria-hidden="true" tabindex="-1"></a><span class="co">#}</span></span>
<span id="cb10-7"><a href="#cb10-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-8"><a href="#cb10-8" aria-hidden="true" tabindex="-1"></a><span class="co"># Load last names dataset</span></span>
<span id="cb10-9"><a href="#cb10-9" aria-hidden="true" tabindex="-1"></a><span class="fu">data</span>(<span class="st">"freq_last_names"</span>, <span class="at">package =</span> <span class="st">"lexicon"</span>)</span>
<span id="cb10-10"><a href="#cb10-10" aria-hidden="true" tabindex="-1"></a><span class="co"># Convert common_names to a dataframe if it is a list</span></span>
<span id="cb10-11"><a href="#cb10-11" aria-hidden="true" tabindex="-1"></a><span class="co">#if (is.list(freq_last_names)) {</span></span>
<span id="cb10-12"><a href="#cb10-12" aria-hidden="true" tabindex="-1"></a>  <span class="co">#freq_last_names &lt;- as.data.frame(freq_last_names)</span></span>
<span id="cb10-13"><a href="#cb10-13" aria-hidden="true" tabindex="-1"></a><span class="co">#}</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>In this next codeblock we are reframing the first and last names and renaming the columns.<br>
Then we combine them into one list of names and convert them into a vector.</p>
<p>We will use this <code>vector of names</code> when trying to find names in our text.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb11"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Rename columns for consistency and add a column to specify name type</span></span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true" tabindex="-1"></a>first_names <span class="ot">&lt;-</span> freq_first_names[, .(<span class="at">name =</span> Name, <span class="at">type =</span> <span class="st">"first_name"</span>)]</span>
<span id="cb11-4"><a href="#cb11-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-5"><a href="#cb11-5" aria-hidden="true" tabindex="-1"></a>last_names <span class="ot">&lt;-</span> freq_last_names[, .(<span class="at">name =</span> Surname, <span class="at">type =</span> <span class="st">"last_name"</span>)]</span>
<span id="cb11-6"><a href="#cb11-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-7"><a href="#cb11-7" aria-hidden="true" tabindex="-1"></a><span class="co"># Combine first and last names and remove duplicates</span></span>
<span id="cb11-8"><a href="#cb11-8" aria-hidden="true" tabindex="-1"></a><span class="co">#all_names &lt;- bind_rows(first_names, last_names) %&gt;%</span></span>
<span id="cb11-9"><a href="#cb11-9" aria-hidden="true" tabindex="-1"></a>  <span class="co">#distinct(name, .keep_all = TRUE)</span></span>
<span id="cb11-10"><a href="#cb11-10" aria-hidden="true" tabindex="-1"></a>all_names <span class="ot">&lt;-</span> <span class="fu">unique</span>(<span class="fu">rbindlist</span>(<span class="fu">list</span>(first_names, last_names)), <span class="at">by =</span> <span class="st">"name"</span>)</span>
<span id="cb11-11"><a href="#cb11-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-12"><a href="#cb11-12" aria-hidden="true" tabindex="-1"></a><span class="co">#Creating a vector of unique names to compare against</span></span>
<span id="cb11-13"><a href="#cb11-13" aria-hidden="true" tabindex="-1"></a>names <span class="ot">&lt;-</span> <span class="fu">unique</span>(all_names[, name])</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Now we are ready to compare our Names list to our text column in the Corona tweets dataframe. to do this we will:</p>
<ol type="1">
<li><p>Tokenize the input - Corona text string - into words</p></li>
<li><p>Check if any of the tokenized words match the list of names we have</p></li>
<li><p>If there is a match this is set to the return value for the column and put in in our Corona tweets data frame</p></li>
</ol>
<div class="cell">
<div class="sourceCode cell-code" id="cb12"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Function to find names in text</span></span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a>find_names <span class="ot">&lt;-</span> <span class="cf">function</span>(text) {</span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true" tabindex="-1"></a>  <span class="co"># Split the text into words</span></span>
<span id="cb12-4"><a href="#cb12-4" aria-hidden="true" tabindex="-1"></a> <span class="co"># words &lt;- str_split(text, "\\s+")[[1]]</span></span>
<span id="cb12-5"><a href="#cb12-5" aria-hidden="true" tabindex="-1"></a>  words <span class="ot">&lt;-</span><span class="fu">unlist</span>(<span class="fu">strsplit</span>(text, <span class="st">"</span><span class="sc">\\</span><span class="st">s+"</span>))</span>
<span id="cb12-6"><a href="#cb12-6" aria-hidden="true" tabindex="-1"></a>  matched_names<span class="ot">=</span><span class="st">""</span></span>
<span id="cb12-7"><a href="#cb12-7" aria-hidden="true" tabindex="-1"></a>  <span class="co"># Check if any words are in the names list</span></span>
<span id="cb12-8"><a href="#cb12-8" aria-hidden="true" tabindex="-1"></a>  matched_names <span class="ot">&lt;-</span> words[words <span class="sc">%in%</span> names]</span>
<span id="cb12-9"><a href="#cb12-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-10"><a href="#cb12-10" aria-hidden="true" tabindex="-1"></a>  <span class="co"># Return matched names or NA if no match</span></span>
<span id="cb12-11"><a href="#cb12-11" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span> (<span class="fu">length</span>(matched_names) <span class="sc">&gt;</span> <span class="dv">0</span>) {</span>
<span id="cb12-12"><a href="#cb12-12" aria-hidden="true" tabindex="-1"></a>    <span class="fu">return</span>(<span class="fu">paste</span>(matched_names, <span class="at">collapse =</span> <span class="st">", "</span>))</span>
<span id="cb12-13"><a href="#cb12-13" aria-hidden="true" tabindex="-1"></a>  } <span class="cf">else</span> {</span>
<span id="cb12-14"><a href="#cb12-14" aria-hidden="true" tabindex="-1"></a>    <span class="fu">return</span>(<span class="cn">NA</span>)</span>
<span id="cb12-15"><a href="#cb12-15" aria-hidden="true" tabindex="-1"></a>  }</span>
<span id="cb12-16"><a href="#cb12-16" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb12-17"><a href="#cb12-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-18"><a href="#cb12-18" aria-hidden="true" tabindex="-1"></a><span class="co"># Apply the function to the text column in our dataframe</span></span>
<span id="cb12-19"><a href="#cb12-19" aria-hidden="true" tabindex="-1"></a>Corona_NLP_DF<span class="ot">&lt;-</span> Corona_NLP_DF <span class="sc">%&gt;%</span></span>
<span id="cb12-20"><a href="#cb12-20" aria-hidden="true" tabindex="-1"></a>  <span class="fu">rowwise</span>() <span class="sc">%&gt;%</span></span>
<span id="cb12-21"><a href="#cb12-21" aria-hidden="true" tabindex="-1"></a>  <span class="fu">mutate</span>(<span class="at">matched_names =</span> <span class="fu">find_names</span>(text))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</section>
<section id="activity-review-the-matched_names-column-in-corona_nlp_df" class="level2">
<h2 class="anchored" data-anchor-id="activity-review-the-matched_names-column-in-corona_nlp_df">ACTIVITY: Review the matched_names column in Corona_NLP_DF</h2>
<p>What sort of problems can you see? Can you think of any ways to fix these? In this activity you;re not asked to actually fix it, just look at the data and write down what you can think of.</p>
<p><em>You can write your findings here</em></p>
<p>After you wrote down some thoughts, have a look at the <a href="./hints/hint_8_1.Rmd">HINT: Answer</a></p>
</section>
<section id="ner-with-pre-trained-models" class="level2">
<h2 class="anchored" data-anchor-id="ner-with-pre-trained-models">NER with pre-trained models</h2>
<p>Next we are going to use some available models that have been pre-trained. We will use <code>nametagger</code> and <code>entity</code> package</p>
<p><code>nametagger</code> allows you to find and extract entities (names, persons, locations, addresses, …) in raw text. You can also train and build your own entity recognition models with this package. The model is based on a maximum entropy Markov model.</p>
<p>You can google <code>R package nametagger</code> to read more about it.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb13"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a>pacman<span class="sc">::</span><span class="fu">p_load</span>(nametagger) <span class="co"># then we can use pacman as usual</span></span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true" tabindex="-1"></a><span class="co">#we need to download the model - we create a directory to put the model in then download the english-conll model.</span></span>
<span id="cb13-4"><a href="#cb13-4" aria-hidden="true" tabindex="-1"></a><span class="fu">dir.create</span>(<span class="st">"models"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stderr">
<pre><code>Warning in dir.create("models"): 'models' already exists</code></pre>
</div>
<div class="sourceCode cell-code" id="cb15"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a>nametagger_model <span class="ot">&lt;-</span> <span class="fu">nametagger_download_model</span>(<span class="st">"english-conll-140408"</span>, <span class="at">model_dir =</span> <span class="st">"models"</span>)</span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-3"><a href="#cb15-3" aria-hidden="true" tabindex="-1"></a><span class="co">#we create a function to run the entity tagger</span></span>
<span id="cb15-4"><a href="#cb15-4" aria-hidden="true" tabindex="-1"></a>extract_entities <span class="ot">&lt;-</span> <span class="cf">function</span>(text) {</span>
<span id="cb15-5"><a href="#cb15-5" aria-hidden="true" tabindex="-1"></a>  result <span class="ot">&lt;-</span> <span class="fu">predict</span>(nametagger_model, text, <span class="at">split =</span> <span class="st">'</span><span class="sc">\\</span><span class="st">s+'</span>)  </span>
<span id="cb15-6"><a href="#cb15-6" aria-hidden="true" tabindex="-1"></a>  <span class="co"># Use mutate to create the merged column and select to keep only that column</span></span>
<span id="cb15-7"><a href="#cb15-7" aria-hidden="true" tabindex="-1"></a>  result</span>
<span id="cb15-8"><a href="#cb15-8" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb15-9"><a href="#cb15-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-10"><a href="#cb15-10" aria-hidden="true" tabindex="-1"></a>show_only_recognised <span class="ot">&lt;-</span> <span class="cf">function</span>(entities){</span>
<span id="cb15-11"><a href="#cb15-11" aria-hidden="true" tabindex="-1"></a>  entities <span class="sc">%&gt;%</span></span>
<span id="cb15-12"><a href="#cb15-12" aria-hidden="true" tabindex="-1"></a>    <span class="fu">filter</span>(entity <span class="sc">!=</span> <span class="st">'O'</span>) <span class="sc">%&gt;%</span></span>
<span id="cb15-13"><a href="#cb15-13" aria-hidden="true" tabindex="-1"></a>    <span class="fu">mutate</span>(<span class="at">full_name =</span> <span class="fu">paste</span>(term, entity, <span class="at">sep =</span> <span class="st">"/"</span>)) <span class="sc">%&gt;%</span></span>
<span id="cb15-14"><a href="#cb15-14" aria-hidden="true" tabindex="-1"></a>    <span class="fu">summarize</span>(<span class="at">all_names =</span> <span class="fu">paste</span>(full_name, <span class="at">collapse =</span> <span class="st">", "</span>))  <span class="co"># Combine into a single string</span></span>
<span id="cb15-15"><a href="#cb15-15" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb15-16"><a href="#cb15-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-17"><a href="#cb15-17" aria-hidden="true" tabindex="-1"></a><span class="co">#Create a text string and run it through the nametagger function</span></span>
<span id="cb15-18"><a href="#cb15-18" aria-hidden="true" tabindex="-1"></a>text <span class="ot">=</span><span class="st">"Hello I am Mary and this is Paul who lives in Scotland. We work as teachers.  We have a cat Meilo and she is a tabby. Scotland is cold and rainy in the winter but I like Scotland"</span></span>
<span id="cb15-19"><a href="#cb15-19" aria-hidden="true" tabindex="-1"></a>entities_in_word <span class="ot">&lt;-</span> <span class="fu">extract_entities</span>(text)</span>
<span id="cb15-20"><a href="#cb15-20" aria-hidden="true" tabindex="-1"></a>entities_in_word</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>   doc_id sentence_id term_id      term entity
1       1           1       1     Hello  B-ORG
2       1           1       1         I      O
3       1           1       1        am      O
4       1           1       1      Mary      O
5       1           1       1       and      O
6       1           1       1      this      O
7       1           1       1        is      O
8       1           1       1      Paul  B-PER
9       1           1       1       who      O
10      1           1       1     lives      O
11      1           1       1        in      O
12      1           1       1 Scotland.      O
13      1           1       1        We      O
14      1           1       1      work      O
15      1           1       1        as      O
16      1           1       1 teachers.      O
17      1           1       1        We      O
18      1           1       1      have      O
19      1           1       1         a      O
20      1           1       1       cat      O
21      1           1       1     Meilo      O
22      1           1       1       and      O
23      1           1       1       she      O
24      1           1       1        is      O
25      1           1       1         a      O
26      1           1       1    tabby.      O
27      1           1       1  Scotland  B-LOC
28      1           1       1        is      O
29      1           1       1      cold      O
30      1           1       1       and      O
31      1           1       1     rainy      O
32      1           1       1        in      O
33      1           1       1       the      O
34      1           1       1    winter      O
35      1           1       1       but      O
36      1           1       1         I      O
37      1           1       1      like      O
38      1           1       1  Scotland  B-LOC</code></pre>
</div>
<div class="sourceCode cell-code" id="cb17"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a><span class="fu">show_only_recognised</span>(entities_in_word)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>                                                all_names
1 Hello/B-ORG, Paul/B-PER, Scotland/B-LOC, Scotland/B-LOC</code></pre>
</div>
<div class="sourceCode cell-code" id="cb19"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true" tabindex="-1"></a>text <span class="ot">=</span><span class="st">"Hello I am Paul and this is Fred we live in Scotland. We work as school teachers.  We have a cat called Bob and he is a tabby. Scotland is cold and rainy in the winter but I like Scotland."</span></span>
<span id="cb19-2"><a href="#cb19-2" aria-hidden="true" tabindex="-1"></a>entities_in_word <span class="ot">&lt;-</span> <span class="fu">extract_entities</span>(text)</span>
<span id="cb19-3"><a href="#cb19-3" aria-hidden="true" tabindex="-1"></a>entities_in_word</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>   doc_id sentence_id term_id      term entity
1       1           1       1     Hello  B-ORG
2       1           1       1         I      O
3       1           1       1        am      O
4       1           1       1      Paul  B-PER
5       1           1       1       and      O
6       1           1       1      this      O
7       1           1       1        is      O
8       1           1       1      Fred  B-PER
9       1           1       1        we      O
10      1           1       1      live      O
11      1           1       1        in      O
12      1           1       1 Scotland.      O
13      1           1       1        We      O
14      1           1       1      work      O
15      1           1       1        as      O
16      1           1       1    school      O
17      1           1       1 teachers.      O
18      1           1       1        We      O
19      1           1       1      have      O
20      1           1       1         a      O
21      1           1       1       cat      O
22      1           1       1    called      O
23      1           1       1       Bob  B-PER
24      1           1       1       and      O
25      1           1       1        he      O
26      1           1       1        is      O
27      1           1       1         a      O
28      1           1       1    tabby.      O
29      1           1       1  Scotland  B-LOC
30      1           1       1        is      O
31      1           1       1      cold      O
32      1           1       1       and      O
33      1           1       1     rainy      O
34      1           1       1        in      O
35      1           1       1       the      O
36      1           1       1    winter      O
37      1           1       1       but      O
38      1           1       1         I      O
39      1           1       1      like      O
40      1           1       1 Scotland.      O</code></pre>
</div>
<div class="sourceCode cell-code" id="cb21"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb21-1"><a href="#cb21-1" aria-hidden="true" tabindex="-1"></a><span class="fu">show_only_recognised</span>(entities_in_word)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>                                                       all_names
1 Hello/B-ORG, Paul/B-PER, Fred/B-PER, Bob/B-PER, Scotland/B-LOC</code></pre>
</div>
</div>
</section>
</section>

</main>
<!-- /main column -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const onCopySuccess = function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  }
  const getTextToCopy = function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
    text: getTextToCopy
  });
  clipboard.on('success', onCopySuccess);
  if (window.document.getElementById('quarto-embedded-source-code-modal')) {
    // For code content inside modals, clipBoardJS needs to be initialized with a container option
    // TODO: Check when it could be a function (https://github.com/zenorocha/clipboard.js/issues/860)
    const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
      text: getTextToCopy,
      container: window.document.getElementById('quarto-embedded-source-code-modal')
    });
    clipboardModal.on('success', onCopySuccess);
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp('/' + window.location.host + '/');
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->




</body></html>